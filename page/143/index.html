<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="../../css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="../../images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="../../atom.xml" title="开发者博客" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="开发者博客">
<meta property="og:url" content="https://luna.newban.cn/page/143/index.html">
<meta property="og:site_name" content="开发者博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="开发者博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
<!--谷歌广告验证代码-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-2626449904708114",
          enable_page_level_ads: true
     });
</script>
<!--谷歌广告验证代码-->



  <link rel="canonical" href="https://luna.newban.cn/page/143/">





  <title>开发者博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
  
<a href="https://www.github.com/songjianzaina" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">开发者博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">开发者的博客 – 全栈</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="http://www.newban.cn/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="http://code.newban.cn/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC如何将参数化的值传递给SystemDataEntitySqlSquery堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC如何将参数化的值传递给SystemDataEntitySqlSquery堆栈内存溢出.html" itemprop="url">cC如何将参数化的值传递给SystemDataEntitySqlSquery堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
C#: How to pass parmeterize values to System.Data.Entity.SqlSquery


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我将直接在数据库上执行SQL查询。 我使用以下命令定义了到数据库的连接：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Data.Entity.DbContext rawDbContext = new DbContext(connectionString);</span><br></pre></td></tr></table></figure>


我不想直接在查询字符串中插入参数以避免SQL注入，因此我想通过以下方式为我的SQL查询设置参数化值：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string sqlCommandString = &quot;IF EXISTS(select* from @MappingTableName where &quot; + Environment.NewLine + &quot;BranchID= @PrimaryKeyID and &quot; + Environment.NewLine + &quot;BranchNo = @BranchNo and &quot; + Environment.NewLine + &quot;TableName = @TableName and &quot; + Environment.NewLine + &quot;BranchSchema = @SchemaNameInBranch and &quot; + Environment.NewLine + &quot;TableID = @TableID) &quot; + Environment.NewLine + &quot; select 1&quot; + Environment.NewLine + &quot;ELSE &quot; + Environment.NewLine + &quot;select 0 &quot; + Environment.NewLine; SqlParameter parameterMappingTableName = new SqlParameter(&quot;@MappingTableName&quot;, vipMappingTableName); SqlParameter parameterSchemaNameInBranch = new SqlParameter(&quot;@SchemaNameInBranch&quot;, schemaName); SqlParameter parameterPrimaryKeyInBranch = new SqlParameter(&quot;@PrimaryKeyID&quot;, primaryNodeId); SqlParameter parameterBranchNo = new SqlParameter(&quot;@BranchNo&quot;, branchNo); SqlParameter parameterTableId = new SqlParameter(&quot;@TableID&quot;, tableId); SqlParameter parameterTableName = new SqlParameter(&quot;@TableName&quot;, tableName); DbRawSqlQuery&lt;int&gt; result = rawDbContext.Database.SqlQuery&lt;int&gt;(sqlCommandString, new[] &#123; parameterMappingTableName, parameterSchemaNameInBranch, parameterPrimaryKeyInBranch, parameterBranchNo, parameterTableId, parameterTableName &#125;); int finalResult = result.Single();</span><br></pre></td></tr></table></figure>


运行此查询将导致"Must declare the table variable \\"@MappingTableName\\"."

我怎样才能解决这个问题？

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：1 已采纳</strong></p>

在Microsoft论坛中查看 数据库对象（表，存储过程或任何其他对象）不能作为参数传递。 仅列或变量的实际值可以是参数。 在这种情况下，您需要动态构建SQL语句 从根本上讲，这意味着您必须提供和/或构建表名，否则可能会受到损害。 如何减轻风险。 声明一组可能的表名称并进行完全匹配。 然后使用文本串联构建查询。 这是无法用参数完成的，因为您无法期望可能的值，但是可以使用表来完成，因为它们太多了。 请谨慎使用名称列表中的“ Equals而不是“ Contains 。

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC如何在按下回车键时停止while循环堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC如何在按下回车键时停止while循环堆栈内存溢出.html" itemprop="url">cC如何在按下回车键时停止while循环堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
C# How to stop while loop when enter pressed


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我有一个家庭作业，我必须制作一个循环询问十次数字的程序，最后给出十个数字的总和。 但是也必须有可能停止循环并在按下Enter键时给出数字的总和。

我在while循环中尝试过类似的方法，但是它也没有用：

if（Console.KeyAvailable && Console.ReadKey（true）.Key == ConsoleKey.Enter）中断;

谁能建议解决方案？

提前致谢！

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; int i = 0; int number; string number_s; int sum = 0; while (i &lt; 10) &#123; &#123; i++; Console.WriteLine(&quot;Enter number:&quot;); number_s = Console.ReadLine(); Int32.TryParse(number_s, out number); sum += number; &#125; &#125; Console.Write(&quot;Sum is: &#123;0&#125;&quot;, sum); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：0</strong></p>

您可以使用if语句来检查输入不是命令停止： 然后，当您编写停止而不是数字时，循环将结束。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> number_s = Console.ReadLine();</span><br><span class="line">if (number_s == &quot;stop&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    i = 11;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    int.TryParse(number_s, out number);</span><br><span class="line">    sum += number;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#2 票数：0</strong></p>

当您按Entery键时， number_s中的值将为空。 您只需要使用

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(string.IsNullOrEmpty(number_s))</span><br><span class="line">break;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#3 票数：0 已采纳</strong></p>

下面的代码应该可以正常工作。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> while (i &lt; 10)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">    Console.WriteLine(&quot;Enter number:&quot;); </span><br><span class="line">    number_s = Console.ReadLine(); </span><br><span class="line">    if(string.IsNullOrEmpty(number_s))</span><br><span class="line">        break;</span><br><span class="line">    input = Convert.ToInt32(number_s);</span><br><span class="line">    sum += input;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;The sum of the entered numbers are : &#123;0&#125;&quot;, sum);</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#4 票数：-1</strong></p>

添加i++; 在while循环中

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int number;</span><br><span class="line">    string number_s;</span><br><span class="line">    int sum = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while (i &lt; 10)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; </span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;Enter number:&quot;); </span><br><span class="line">        number_s = Console.ReadLine(); </span><br><span class="line">        Int32.TryParse(number_s, out number);</span><br><span class="line"></span><br><span class="line">            sum += number;</span><br><span class="line"></span><br><span class="line">         i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   Console.Write(&quot;Sum is: &#123;0&#125;&quot;, sum);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC多线程无符号增量堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC多线程无符号增量堆栈内存溢出.html" itemprop="url">cC多线程无符号增量堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
C# multi-threaded unsigned increment


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我想从多个线程增加一个无符号整数。

我知道Interlocked.Increment，但是它不处理无符号整数。 我可以使用lock（），但出于性能原因，我不希望这样做。

以正常方式递增线程安全吗？ 偶然的增量是否丢失并不重要，因为它仅用于统计。 我不希望被破坏的价值。

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：41 已采纳</strong></p>

您说出于性能原因不想使用lock -但是您已经测试过了吗？ 毫无争议的锁（听起来很可能是这样）非常便宜。 在线程方面，我通常选择“明显正确”，而不是“聪明并且可能表现更好”（通常，尤其是对于线程）。 使用和不使用锁定对您的应用程序进行基准测试，看看您是否还能注意到其中的区别。 如果锁定有很大的不同，那么请确保使用狡猾的东西。 否则，我只会坚持锁。 您可能想做的一件事是将Interlocked.Increment与int配合使用，并在需要时将其uint转换为uint ，例如： 输出： （换句话说，它包装起来没有问题。）

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> using System;</span><br><span class="line">using System.Reflection;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private static int count = int.MaxValue-1;</span><br><span class="line"></span><br><span class="line">    public static uint IncrementCount()</span><br><span class="line">    &#123;</span><br><span class="line">        int newValue = Interlocked.Increment(ref count);</span><br><span class="line">        return unchecked((uint) newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(IncrementCount());</span><br><span class="line">        Console.WriteLine(IncrementCount());</span><br><span class="line">        Console.WriteLine(IncrementCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#2 票数：11</strong><br><strong>===============&gt;&gt;#3 票数：0</strong></p>

在使用带符号整数的二进制补码表示的系统上（根据维基百科， “几乎所有” ），递增无符号整数的作用与递增使用相同位集表示的有符号整数的作用相同。 因此，可以在不牺牲任何内容的情况下对无符号整数使用InterlockedIncrement。 例如，使用3位，我们有下表： 在两种情况下，增加1（并考虑溢出）都等于将表中的一项向下移动。 请注意，这对于“ 1”补码算术无效，因为负数的排列顺序相反。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> raw bits | unsigned integer | twos complement signed integer</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">000      |                0 |                             0 </span><br><span class="line">001      |                1 |                             1 </span><br><span class="line">010      |                2 |                             2 </span><br><span class="line">011      |                3 |                             3 </span><br><span class="line">100      |                4 |                            -4 </span><br><span class="line">101      |                5 |                            -3</span><br><span class="line">110      |                6 |                            -2</span><br><span class="line">111      |                7 |                            -1</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#4 票数：0</strong></p>

根据前肾脏的答案 ，您可以创建自己的帮助程序类。 由于增量将在二进制级别上以相同的方式起作用，因此您可以在使用Unsafe类进行增量之前将类型从无符号更改为有符号：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> using System.Runtime.CompilerServices;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">public static class InterlockedEx</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// unsigned equivalent of &lt;see cref=&quot;Interlocked.Increment(ref Int32)&quot;/&gt;</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public static ulong Increment(ref uint location)</span><br><span class="line">    &#123;</span><br><span class="line">        int incrementedSigned = Interlocked.Increment(ref Unsafe.As&lt;uint, int&gt;(ref location));</span><br><span class="line">        return Unsafe.As&lt;int, uint&gt;(ref incrementedSigned);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// unsigned equivalent of &lt;see cref=&quot;Interlocked.Increment(ref Int64)&quot;/&gt;</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public static ulong Increment(ref ulong location)</span><br><span class="line">    &#123;</span><br><span class="line">        long incrementedSigned = Interlocked.Increment(ref Unsafe.As&lt;ulong, long&gt;(ref location));</span><br><span class="line">        return Unsafe.As&lt;long, ulong&gt;(ref incrementedSigned);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#5 票数：-15</strong></p>

您可以将uint声明为volatile。 http://msdn.microsoft.com/zh-CN/library/x13ttww7(VS.71).aspx

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC多个工作线程和承诺堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC多个工作线程和承诺堆栈内存溢出.html" itemprop="url">cC多个工作线程和承诺堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
c++ Multiple worker threads and promises


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我有一个线程安全队列，该队列由主线程预先填充； 当我启动工作线程时，它们会从工作队列中弹出任务，而且还可以将新任务推回到工作队列中（有时工作线程确实会推回更多的工作，有时却不会）。 简要了解一下代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto work_queue = safe_queue&#123;&#125;; static void handle_task(T task) &#123; // process the task // might push a new task to a work queue using work_queue.push() &#125; int main() &#123; //some work is done to prepopulate work_queue auto handle_work = []()&#123; while (!work_queue.empty) &#123; T task = work_queue.pop(); handle_task(task); &#125; &#125;; std::vector&lt;std::thread&gt; threads; for (int i = 0; i &lt; NUM_OF_THREADS; i++) &#123; threads.push_back(std::thread(processing)); &#125; std::for_each(threads.begin(), threads.end(), [](std::thread &amp;t) &#123; t.join(); &#125; &#125;</span><br></pre></td></tr></table></figure>


我了解此代码将无法正常工作，因为在某些情况下，当某些工作线程正在处理工作时队列可能为空，而其他线程进来时却找不到工作并退出（尽管线程处理任务可能会将新工作推回队列）。 我的问题是，如何防止线程过早退出？ 使用std::promise<void>允许线程与它们仍在工作的其他线程进行通信是否可行？ 如果是这样，它将如何与多个线程一起工作（我是C ++的新手，仅对单线程使用了promise）？

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：1 已采纳</strong></p>

我不认为std::promise<void>可以在这里使用，因为它更像是一口气。 将来设定结果之后，就无法取消设定，因此我们不能再等待两次以实现相同的承诺。 一个人可以执行以下操作（必须使计数器成为线程安全的，但是我现在懒得这样做）： 这应该仅在所有线程完成后退出（如：它们不再处理任务，并且队列中没有非任务）。 然后，将不再有新任务放入队列。 局部变量可最大程度地减少对共享内存的访问。 请注意，我在多线程编程方面的经验非常有限。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> int finished_threads = 0;</span><br><span class="line">auto handle_work = [&amp;finished_threads]()&#123;</span><br><span class="line">    bool this_finished = false;</span><br><span class="line">    while (finished_threads &lt; NUM_OF_THREADS) &#123;</span><br><span class="line">      while (!work_queue.empty) &#123;</span><br><span class="line">        if(this_finished) &#123;</span><br><span class="line">          this_finished = false;</span><br><span class="line">          --finished_threads;  // evil</span><br><span class="line">        &#125;</span><br><span class="line">        T task = work_queue.pop();</span><br><span class="line">        handle_task(task);</span><br><span class="line">      &#125;</span><br><span class="line">      if(!this_finished) &#123;</span><br><span class="line">        this_finished = true;</span><br><span class="line">        ++finished_threads; // evil</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#2 票数：0</strong></p>

我用std::condition_variable尝试了完全不同的东西： 不知道它是否更好，但是肯定更复杂^^。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;vector&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;optional&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">constexpr int NUM_OF_THREADS = 5;</span><br><span class="line">std::condition_variable input_cv;</span><br><span class="line">std::condition_variable callback_cv;</span><br><span class="line">std::optional&lt;int&gt; data &#123;&#125;;</span><br><span class="line">std::mutex m;</span><br><span class="line">std::mutex callback_mutex;</span><br><span class="line">int finished_threads = 0;</span><br><span class="line"></span><br><span class="line">static void handle_task(int i)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct worker </span><br><span class="line">&#123;</span><br><span class="line">    const int num;</span><br><span class="line">    worker () = delete;</span><br><span class="line">    void operator()() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; lk(m);</span><br><span class="line">            ++finished_threads; // protected by m</span><br><span class="line">            callback_cv.notify_one(); // wake up main thread if it sleeps</span><br><span class="line">            input_cv.wait(lk);</span><br><span class="line">            if(!data)</span><br><span class="line">                return;</span><br><span class="line">            --finished_threads; // protected by m</span><br><span class="line">            int local_data = *data;</span><br><span class="line">            lk.unlock();</span><br><span class="line"></span><br><span class="line">            handle_task(local_data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct safe_queue // dummy</span><br><span class="line">&#123;</span><br><span class="line">    int pop () const &#123; return 0; &#125;</span><br><span class="line">    bool empty() const &#123;return true;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main_thread ()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;</span><br><span class="line">    safe_queue work_queue;</span><br><span class="line">    for(int i = 0; i &lt; NUM_OF_THREADS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        workers.emplace_back(worker&#123;i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; guard(m);</span><br><span class="line">                data.emplace(work_queue.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            input_cv.notify_one();</span><br><span class="line">        &#125; while(!work_queue.empty() &amp;&amp; finished_threads &gt; 0)</span><br><span class="line">        // If no thread has finished, we can wait for the next one to finish.</span><br><span class="line"></span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lk(callback_mutex);</span><br><span class="line">        callback_cv.wait(lk); // We wait on some thread to have finished</span><br><span class="line">    &#125;while(finished_threads &lt; NUM_OF_THREADS &amp;&amp; !work_queue.empty()); // In either case, there remains something to do.</span><br><span class="line"></span><br><span class="line">    data = &#123;&#125;;</span><br><span class="line">    input_cv.notify_all();</span><br><span class="line"></span><br><span class="line">    std::for_each(begin(workers), end(workers), [](std::thread &amp;t) &#123; t.join();&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    std::thread t(main_thread);</span><br><span class="line"></span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</void></void>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC在初始化char和char之后char显示在char中堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC在初始化char和char之后char显示在char中堆栈内存溢出.html" itemprop="url">cC在初始化char和char之后char显示在char中堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
C++ after initialize char[] and char , char shows in the char[]


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我最近在学习Cpp，今天，当我使用Clion学习做一些测试时，奇怪的事情发生了。

这是我的代码

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123; char c = &apos;b&apos;; char carr[1]&#123;&apos;a&apos;&#125;; char *p1 =&amp;(carr[0]); char *p2 =&amp;c; return 0; &#125;</span><br></pre></td></tr></table></figure>


编译器：

4.2.1兼容的Apple LLVM 11.0.0（clang-1100.0.33.8）

lldb：

这是内存的详细信息：

请帮我找出原因！

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：2 已采纳</strong></p>

变量carr的类型为char[1] ，它会衰减为char* 。 尝试打印char*调试器将继续打印char，直到到达空终止符\\0为止。 不是carr包含"ab" ，而是任何查看carr函数都假定它包含。 这是因为当数组的边界传递给另一个函数时（几乎总是）将其丢弃。

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC初学者有关数组和指针的问题堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC初学者有关数组和指针的问题堆栈内存溢出.html" itemprop="url">cC初学者有关数组和指针的问题堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
C++: Questions about array and pointer from a beginner


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我是C ++和一般编程人员的新手。 当我学习了指针和数组的概念时，我感到困惑。 取int*p = arr; int arr[]={5,1}; 举个例子。 我了解到arr也是一个指针。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p(a pointer) arr[0] the thing it stores: [first element address: 601] [5] its memory : 501 601 address(just make some fake address) However, arr(the pointer) [first element address: 601] 601</span><br></pre></td></tr></table></figure>


通常，指针应具有与数组不同的地址。 但是，作为指向第一个元素的指针的arr具有与第一个元素相同的地址。 所以我感到困惑。 而且我想知道是否是因为arr[0]的存储盒分为两部分： arr[0]一部分和指针arr一部分，以便它们在内存中具有相同的地址。

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：0</strong></p>

我建议指针不是C ++中的新手话题，它们大多只是C的遗留物。如果可以的话，应避免使用它们并使用STL容器 。 在您的代码示例中， arr的类型为int[2] 。 您应该在内存中将其视为如下所示： arr包含的值是第一个元素（ 5 ）的位置。 arr本质上是指向5的指针。 唯一的区别是类型（ int[2] ）还记住了有多少个元素。 赋值语句p = arr起作用是因为p的类型是int* ，而int[]可以归为int* 。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr --+</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">   +---+---+</span><br><span class="line">   | 5 | 1 |</span><br><span class="line">   +---+---+</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#2 票数：0</strong></p>

我了解到arr也是一个指针。 然后，您被教会了一些错误，这可能是您感到困惑的原因。 如果您有int arr[] = {5, 1}; 那么arr是一个数组，而不是指针。 数组可以隐式转换为指向其第一个元素的指针。 但是数组本身仍然是一个数组。 例如，使一个int arr[512]; 并检查sizeof(arr)将是什么。 如果arr是指针，则应与sizeof(int*) 。 不会的，因为数组不是指针。 它们是数组… 如果你写 然后arr在p的初始化中隐式转换为指向其第一个元素的指针，就像这里 在blub的初始化中，整数i被隐式转换为双blub 。 如果采用&arr之类的数组的地址，则结果将是指向完整数组对象的指针（该数组对象包含所有数组元素作为子对象）。 完整数组的地址将与其第一个元素的地址相同，但是指针将具有不同的类型。 例如： 这将无法编译，因为&arr的类型是“指向三个int的数组的指针”，而不仅仅是“指向int的指针”。 同时， p是一个单独的对象，因此它自然具有不同的地址。 &p的类型将为“指向int的指针”…

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> int arr[] = &#123;1, 2, 3&#125;;</span><br><span class="line">int* p = arr;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC交换矩阵的行使用单维数组堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC交换矩阵的行使用单维数组堆栈内存溢出.html" itemprop="url">cC交换矩阵的行使用单维数组堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
C++: Swap Rows For A Matrix: Using a SINGLE DIMENSION Array


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
亲爱的聪明人，您能否与我分享为什么我的代码无法将行交换为矩阵的原因？ 当我运行代码时，两行都变为相同，omg。

entry [i]是在矩阵中存储元素的动态数组。 元素从左到右逐行存储。 也就是说，在3X3矩阵中，entries [2]是第一行的第3个元素，entries [3]是第二行的第一个元素

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = number of rows in matrix m = number of columns in matrix void Matrix::SwapRows(int i, int j) &#123; double* temp; temp = new double[n * m]; double* temp2; temp2 = new double[n * m]; for (int a = 1; a &lt;= n; a++) &#123; for (int b = 1; b &lt;= m; b++) &#123; if (a == i) &#123; temp[(j - 1) * m + b - 1] = entries[(j - 1) * m + b - 1]; entries[(a - 1) * m + b - 1] = temp[(j - 1) * m + b - 1]; &#125; if (a == j) &#123; temp2[(i - 1) * m + b - 1] = entries[(i - 1) * m + b - 1]; entries[(a - 1) * m + b - 1] = temp2[(i - 1) * m + b - 1]; &#125; &#125; &#125; delete temp; delete temp2; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：0</strong></p>

THanx给Jesper Juhl，swap帮了大忙。 正确的方法如下。 谢谢杰斯珀！

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> void Matrix::SwapRows(int i, int j) &#123;</span><br><span class="line">    for (int a = 1; a &lt;= n; a++) &#123;</span><br><span class="line">        for (int b = 1; b &lt;= m; b++) &#123;</span><br><span class="line">            if (a == i) &#123;</span><br><span class="line">                swap (entries[(a - 1) * m + b - 1], entries[(j - 1) * m + b - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../c如何使用aspnet创建树形视图结构保留堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../c如何使用aspnet创建树形视图结构保留堆栈内存溢出.html" itemprop="url">c如何使用aspnet创建树形视图结构保留堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
How to create a tree view structure using asp.net [on hold]


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
希望你一切都好！

任何人都可以帮助我创建以下网页。. 在此处输入图片描述

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC中的签名溢出和未定义的行为UB堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC中的签名溢出和未定义的行为UB堆栈内存溢出.html" itemprop="url">cC中的签名溢出和未定义的行为UB堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
Signed overflow in C++ and undefined behaviour (UB)


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我想知道以下代码的使用

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result = 0; int factor = 1; for (...) &#123; result = ... factor *= 10; &#125; return result;</span><br></pre></td></tr></table></figure>


如果循环迭代了n次，则factor乘以10恰好是n次。 然而， factor仅曾经已经被乘以后使用10总共n-1次。 如果我们假设除循环的最后一次迭代外， factor永远不会溢出，而是可能在循环的最后一次迭代中溢出，那么这样的代码是否可以接受？ 在这种情况下，事实证明在发生溢出后永远不会使用factor的值。

我正在就是否应接受此类代码进行辩论。 可以将乘法放在if语句中，并且在可能溢出时，不对循环的最后一次迭代进行乘法。 缺点是它会使代码混乱，并添加了一个不必要的分支，需要在所有先前的循环迭代中进行检查。 我还可以减少循环迭代一次，并在循环之后复制一次循环主体，这又使代码复杂化。

有问题的实际代码在一个紧密的内部循环中使用，该循环在实时图形应用程序中消耗大量的总CPU时间。

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：23</strong></p>

编译器确实假定有效的C ++程序不包含UB。 考虑例如： 如果x == nullptr则取消引用它并分配一个值是UB。 因此，在有效程序中结束的唯一方法是，当x == nullptr永远不会产生true且编译器可以假设在if规则下，上述等效于： 现在在您的代码中 在有效程序中不能发生factor的最后乘法（未定义有符号溢出）。 因此， result分配也不可能发生。 由于无法在最后一次迭代之前进行分支，因此先前的迭代也不会发生。 最终，正确的代码部分（即，从未发生未定义的行为）是：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> if (x == nullptr) &#123;</span><br><span class="line">    *x = 3;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    *x = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#2 票数：22</strong></p>

int溢出的行为是不确定的。 是否在循环体之外读取factor无关紧要； 如果它已经溢出了，那么在未定义溢出之前 ，之后和之前有些矛盾的代码行为。 保留此代码可能出现的一个问题是，在进行优化时，编译器变得越来越激进。 特别是，他们正在养成一种习惯，即他们假设从未发生过未定义的行为。 为此，他们可能会完全删除for循环。 你不能用一个unsigned类型factor虽然，那么你就需要大约不必要的转换忧虑int到unsigned包含两个表达式？
**===============>>#3 票数：8**

考虑现实世界中的优化器可能会很有见识。 循环展开是已知的技术。 op循环展开的基本思想是 可能更好地在幕后实施，因为 这是简单的情况，具有固定范围。 但是现代编译器也可以对变量范围执行此操作： 变成 显然，这仅在编译器知道N <= 3时有效。 这就是我们回到原始问题的地方。 因为编译器知道不会发生带符号的溢出 ，所以它知道循环在32位体系结构上最多可以执行9次。 10^10> 2^32 。 因此，它可以进行9次迭代循环展开。 但是预期的最大值是10次迭代！ 。 可能发生的是，您获得了相对跳转到N = 10的汇编指令（9-N），因此偏移量为-1，这是跳转指令本身。 哎呀。 对于定义良好的C ++，这是完全有效的循环优化，但是给出的示例变成了紧密的无限循环。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i != 3; ++i)</span><br><span class="line">   foo()</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#4 票数：7</strong></p>

任何有符号整数溢出都会导致未定义的行为，而不管是否已读取或可能会读取溢出的值。 也许在您的用例中，您可以将第一个迭代移出循环，将其 进入这个 启用优化后，编译器可能会将上面的第二个循环展开为一个条件跳转。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> int result = 0;</span><br><span class="line">int factor = 1;</span><br><span class="line">for (int n = 0; n &lt; 10; ++n) &#123;</span><br><span class="line">    result += n + factor;</span><br><span class="line">    factor *= 10;</span><br><span class="line">&#125;</span><br><span class="line">// factor &quot;is&quot; 10^10 &gt; INT_MAX, UB</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#5 票数：3</strong></p>

如果您可以忍受循环中的一些其他汇编说明，而不是 你可以写： 避免最后的乘法。 !factor不会引入分支： 这段代码 优化后也会导致无分支装配： （与GCC 8.3.0 -O3一起编译）

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> int factor = 1;</span><br><span class="line">for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">    ...</span><br><span class="line">    factor *= 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#6 票数：1</strong></p>

考虑以下功能： 根据已发布的基本原理，该标准的作者曾希望，如果在（例如）一台使用参数0xC000和0xC000的普通32位计算机上调用此函数，则将*的操作数提升为有signed int会导致计算结果yield -0x10000000，当转换为unsigned将产生0x90000000u －就像他们将unsigned short提升为unsigned 。 但是，gcc有时会以某种方式优化该功能，如果发生溢出，这种方式会表现得毫无意义。 某些输入组合可能导致溢出的代码都必须使用-fwrapv选项进行处理，除非允许故意变形的输入的创建者执行他们选择的任意代码是可以接受的。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> unsigned mull_mod_65535(unsigned short a, unsigned short b)</span><br><span class="line">&#123;</span><br><span class="line">  return (a*b) &amp; 0xFFFFu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#7 票数：0</strong></p>

这是UB； 用ISO C ++术语来说，整个程序的整个行为是完全不确定的，因为它最终会击中UB。 编译器可以在编译时为执行路径“造成麻烦”，他们可以看到它们导致了编译时可见的UB，例如，假定从未到达那些基本块。 另请参见每个C程序员应了解的未定义行为 （LLVM博客）。 如此处所述，带符号溢出的UB可使编译器证明for(... i <= n ...)循环不是无限循环，即使对于未知n 。 它还允许他们将int循环计数器“提升”为指针宽度，而不是重做符号扩展。 （因此，在这种情况下，ub的结果可能是在数组的低64k或4g元素外部访问，如果您期望使用i包装。 在某些情况下，编译器将针对某个块发出x86 ud2类的非法指令，如果执行该块可证明会导致ub。 （请注意，一个函数可能永远不会被调用，所以编译器一般不能发狂，并通过不打ub功能突破等功能，甚至可能路径。即机器代码，它编译成仍须工作所有不会导致ub的输入。） 可能最有效的解决方案是手动剥离最后一次迭代，以便可以避免不必要的factor*="10" 或者，如果循环体很大，请考虑为factor使用简单的无符号类型。 即使您将其与带符号的类型一起使用。 无符号和2的补码之间的转换是免费的（所有值都使用相同的位模式）； c ++标准指定的int-> unsigned的模数包装简化为仅使用相同的位模式，而不像一个人的补码或符号/幅度。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> int result = 0;</span><br><span class="line">int factor = 1;</span><br><span class="line">for (... i &lt; n-1) &#123;   // stop 1 iteration early</span><br><span class="line">    result = ...</span><br><span class="line">    factor *= 10;</span><br><span class="line">&#125;</span><br><span class="line"> result = ...      // another copy of the loop body, using the last factor</span><br><span class="line"> //   factor *= 10;    // and optimize away this dead operation.</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>

</=></=>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luna.newban.cn../../cC中的并行编程未执行指令堆栈内存溢出.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="开发者">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开发者博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../cC中的并行编程未执行指令堆栈内存溢出.html" itemprop="url">cC中的并行编程未执行指令堆栈内存溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-28T00:00:00+00:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原文标题"><a href="#原文标题" class="headerlink" title="原文标题:"></a>原文标题:</h2>
Parallel programming in C not executing instructions


<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2>
我需要有关C并行编程的帮助，来自该图： graph image

我写了这段代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main () &#123; int r2; printf(&quot;--------- Program start ---------&quot;); printf(&quot;\nBlock A instructions&quot;); //block A printf(&quot;\nBlock B instructions&quot;); //block B r2= fork(); if (r2==0)&#123; //child printf(&quot;\nBlock E instructions&quot;); //block E printf(&quot;\nBlock F instructions&quot;); //block F exit(0); &#125; else&#123; if (r2&gt;0)&#123; //father printf(&quot;\nBlock C instructions&quot;); //block C printf(&quot;\nBlock D instructions&quot;); //block D exit(0); &#125; else printf(&quot;\nError&quot;); &#125; printf(&quot;\nBlock G instructions&quot;); //block G printf(&quot;\nBlock H instructions&quot;); //block H printf(&quot;\n--------- Program finish ---------&quot;); &#125;</span><br></pre></td></tr></table></figure>


输出为：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------- Program start --------- Block A instructions Block B instructions Block E instructions Block F instructionsBlock B instructions Block C instructions Block D instructions</span><br></pre></td></tr></table></figure>


程序为什么不写其他指令，为什么又写两次“块B指令”？

---------------------编辑：---------------------

新的代码是：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main () &#123; printf(&quot;--------- Program start ---------\n&quot;); printf(&quot;Block A instructions\n&quot;); //block A printf(&quot;Block B instructions\n&quot;); //block B fflush(stdout); pid_t r2= fork(); if (r2==0)&#123; //child printf(&quot;Block E instructions\n&quot;); //block E printf(&quot;Block F instructions\n&quot;); //block F fflush(stdout); exit(1); &#125; else&#123; if (r2&gt;0)&#123; //father printf(&quot;Block C instructions\n&quot;); //block C printf(&quot;Block D instructions\n&quot;); //block D fflush(stdout); wait(NULL); //wait for child process to join with this parent, returns no value &#125; else printf(&quot;Error&quot;); &#125; printf(&quot;Block G instructions\n&quot;); //block G printf(&quot;Block H instructions\n&quot;); //block H printf(&quot;--------- Program finish ---------&quot;); return 0; &#125;</span><br></pre></td></tr></table></figure>


现在的输出是：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------- Program start --------- Block A instructions Block B instructions Block E instructions Block F instructions Block C instructions Block D instructions Block G instructions Block H instructions --------- Program finish ---------</span><br></pre></td></tr></table></figure>


有时C和D指令是在E和F指令之前编写的，这是正常的还是应该始终是EF-> CD？ 顺便说一句，代码是好的还是有一些错误？ 我使用-Wall进行了编译，但未收到任何错误消息

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p><strong>===============&gt;&gt;#1 票数：2 已采纳</strong></p>

<stdio.h>已缓冲 ，请参见stdio（3）和setvbuf（3） 。 您应该在适当的地方调用fflush（3） ，尤其是在fork（2）之前。 顺便说一句，您的标准libc的代码是自由软件 ，可能是GNU glibc 。 当然，它使用syscalls（2） 。 因此，您应该研究其源代码。 容易出错。 \\n可以刷新缓冲区，并且在实践中应将其用作printf（3）控制格式字符串的最后一个字符。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;\\nBlock C instructions&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>===============&gt;&gt;#2 票数：1</strong></p>

由于存在exit(0) ，因此它不会打印其他指令，因此它将永远不会到达G和H块。 对于要打印两次的B，请参阅Basile Starynkevitch的答案。
</stdio.h>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="../142/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../142/">142</a><span class="page-number current">143</span><a class="page-number" href="../144/">144</a><span class="space">&hellip;</span><a class="page-number" href="../173/">173</a><a class="extend next" rel="next" href="../144/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">开发者</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="http://code.newban.cn/archives/">
              
                  <span class="site-state-item-count">1724</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="../../atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">开发者</span>
  <div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  </div>
  
</div>


  <div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a rel="external nofollow" class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="../../lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="../../lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="../../js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="../../js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="../../js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
